<section id="prompt-section" class="prompt-shell" aria-label="Interactive terminal prompt">
  <div class="prompt-output" data-prompt-output role="log" aria-live="polite" aria-relevant="additions"></div>

  <div class="prompt-entry">
    <label for="prompt-command" class="sr-only">Terminal command</label>
    <span class="prompt" aria-hidden="true">pasha@portfolio:~$</span>
    <input
      id="prompt-command"
      name="cmd"
      class="prompt-input"
      type="text"
      inputmode="text"
      autocomplete="off"
      spellcheck="false"
      aria-describedby="prompt-hint"
      placeholder=""
    >
    <span class="cursor" aria-hidden="true"></span>
  </div>

  <p id="prompt-hint" class="prompt-hint">Type <code>help</code> and press Enter. Shortcut: <code>/</code> focuses prompt.</p>

  <noscript>
    <p class="prompt-hint">JavaScript is off. Visit <a href="/blog">/blog</a> or open <a href="/files/resume-cv.pdf">resume.pdf</a>.</p>
  </noscript>
</section>

<script is:inline>
  (() => {
    const input = document.getElementById('prompt-command');
    const output = document.querySelector('[data-prompt-output]');

    if (!input || !output) {
      return;
    }

    const MAX_HISTORY = 50;
    const MAX_OUTPUT_LINES = 180;
    const commandHistory = [];
    let historyIndex = 0;

    const cursor = document.querySelector('.cursor');
    const promptEntry = document.querySelector('.prompt-entry');
    const promptLabel = document.querySelector('.prompt-entry .prompt');

    const updateCursorPosition = () => {
      if (!cursor || !promptEntry || !promptLabel || !(input instanceof HTMLInputElement)) {
        console.warn('updateCursorPosition: missing element', { cursor, promptEntry, promptLabel, input });
        return;
      }
      
      // Set prompt width CSS variable
      const promptWidth = promptLabel.getBoundingClientRect().width;
      promptEntry.style.setProperty('--prompt-width', `${promptWidth}px`);
      
      // Measure text up to cursor position
      const cursorPos = input.selectionStart || 0;
      const textBeforeCursor = input.value.substring(0, cursorPos);
      
      // Create temporary span to measure width - use canvas for more accurate measurement
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      if (!ctx) return;
      
      const computedStyle = window.getComputedStyle(input);
      ctx.font = `${computedStyle.fontSize} ${computedStyle.fontFamily}`;
      const metrics = ctx.measureText(textBeforeCursor);
      const width = metrics.width;
      
      console.log('Cursor update:', { textBeforeCursor, width, cursorPos, inputValue: input.value });
      
      // Position cursor
      cursor.style.transform = `translateX(${width}px)`;
    };

    const isEditableTarget = (target) => {
      if (!(target instanceof HTMLElement)) return false;
      if (target.isContentEditable) return true;
      const tag = target.tagName;
      return tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT';
    };

    const trimOutput = () => {
      while (output.childElementCount > MAX_OUTPUT_LINES) {
        output.firstElementChild?.remove();
      }
      output.scrollTop = output.scrollHeight;
    };

    const appendCommand = (text) => {
      const line = document.createElement('p');
      line.className = 'prompt-line prompt-line-command';

      const promptLabel = document.createElement('span');
      promptLabel.className = 'prompt';
      promptLabel.textContent = 'pasha@portfolio:~$';
      line.appendChild(promptLabel);
      line.append(` ${text}`);

      output.appendChild(line);
      trimOutput();
    };

    const appendResponse = (text) => {
      const line = document.createElement('p');
      line.className = 'prompt-line prompt-line-response';
      line.textContent = text;
      output.appendChild(line);
      trimOutput();
    };

    const appendLink = (label, href, external = false) => {
      const line = document.createElement('p');
      line.className = 'prompt-line prompt-line-response';

      const anchor = document.createElement('a');
      anchor.className = 'prompt-link';
      anchor.href = href;
      anchor.textContent = label;
      if (external) {
        anchor.target = '_blank';
        anchor.rel = 'noreferrer noopener';
      }

      line.appendChild(anchor);
      output.appendChild(line);
      trimOutput();
    };

    const printHelp = () => {
      appendResponse('about  - show short bio');
      appendResponse('links  - show primary links');
      appendResponse('blog   - open /blog');
      appendResponse('resume - open resume.pdf');
      appendResponse('clear  - clear terminal output');
      appendResponse('help   - show this help');
    };

    const runCommand = (rawValue) => {
      const value = rawValue.trim();
      if (!value) return;

      const command = value.toLowerCase();

      // Preserve terminal behavior: clear should wipe the screen entirely, including the typed line.
      if (command === 'clear') {
        output.innerHTML = '';
        return;
      }

      appendCommand(value);

      switch (command) {
        case 'about':
          appendResponse('Pasha Fateev - software engineer focused on reliable backend systems with Python and Go.');
          appendResponse('Currently building release engineering automation and practical AI-assisted workflows.');
          break;
        case 'links':
          appendLink('github     https://github.com/pashafateev', 'https://github.com/pashafateev', true);
          appendLink('linkedin   https://www.linkedin.com/in/pashafateev/', 'https://www.linkedin.com/in/pashafateev/', true);
          appendLink('blog       /blog', '/blog');
          appendLink('resume     /files/resume-cv.pdf', '/files/resume-cv.pdf', true);
          break;
        case 'blog':
          window.location.assign('/blog');
          break;
        case 'resume': {
          const resumeUrl = '/files/resume-cv.pdf';
          const win = window.open(resumeUrl, '_blank', 'noopener');
          if (!win) {
            window.location.assign(resumeUrl);
          }
          appendResponse('Opening resume.pdf...');
          break;
        }
        case 'help':
          printHelp();
          break;
        default:
          appendResponse(`Command not found: ${command}. Type "help" for available commands.`);
      }
    };

    const submitCommand = () => {
      const value = input.value.trim();
      if (!value) return;

      commandHistory.push(value);
      if (commandHistory.length > MAX_HISTORY) {
        commandHistory.shift();
      }
      historyIndex = commandHistory.length;

      runCommand(value);
      input.value = '';
      updateCursorPosition();
    };

    // Update cursor on input
    input.addEventListener('input', updateCursorPosition);
    input.addEventListener('click', updateCursorPosition);
    input.addEventListener('keyup', updateCursorPosition);
    
    // Show/hide cursor based on focus
    input.addEventListener('focus', () => {
      if (cursor) cursor.style.opacity = '1';
      updateCursorPosition();
    });
    
    input.addEventListener('blur', () => {
      if (cursor) cursor.style.opacity = '0';
    });
    
    // Initialize cursor position
    updateCursorPosition();

    input.addEventListener('keydown', (event) => {
      if (event.key === 'Enter') {
        event.preventDefault();
        submitCommand();
        return;
      }

      if (event.key === 'ArrowUp') {
        if (commandHistory.length === 0) return;
        event.preventDefault();
        historyIndex = Math.max(0, historyIndex - 1);
        input.value = commandHistory[historyIndex] ?? '';
        setTimeout(updateCursorPosition, 0);
        return;
      }

      if (event.key === 'ArrowDown') {
        if (commandHistory.length === 0) return;
        event.preventDefault();
        historyIndex = Math.min(commandHistory.length, historyIndex + 1);
        input.value = historyIndex === commandHistory.length ? '' : commandHistory[historyIndex] ?? '';
        setTimeout(updateCursorPosition, 0);
      }
    });

    document.addEventListener('keydown', (event) => {
      if (event.defaultPrevented || event.altKey || event.ctrlKey || event.metaKey) {
        return;
      }

      const target = event.target;

      if (event.key === '/' && !isEditableTarget(target)) {
        event.preventDefault();
        input.focus();
        return;
      }

      if (event.key === 'Escape' && document.activeElement === input) {
        input.blur();
      }
    });
  })();
</script>

<style>
  .prompt-shell {
    display: grid;
    gap: 10px;
    margin-top: 4px;
  }

  .prompt-output {
    display: grid;
    gap: 6px;
    max-height: min(48vh, 320px);
    overflow-y: auto;
    padding-right: 4px;
  }

  .prompt-line {
    margin: 0;
    word-break: break-word;
  }

  .prompt-line-command {
    color: var(--term-fg);
  }

  .prompt-line-response {
    color: var(--term-dim);
  }

  .prompt-entry {
    position: relative;
    display: grid;
    grid-template-columns: auto minmax(0, 1fr);
    gap: 8px;
    align-items: center;
    min-height: 44px;
  }
  
  .cursor {
    position: absolute;
    left: calc(var(--prompt-width, 0px) + 8px);
    pointer-events: none;
    transition: transform 50ms ease-out;
    opacity: 0;
  }
  
  .prompt-input:focus ~ .cursor {
    opacity: 1;
  }

  .prompt-input {
    width: 100%;
    border: 0;
    color: var(--term-fg);
    background: transparent;
    font: inherit;
    min-height: 44px;
    padding: 0;
    caret-color: transparent;
  }

  .prompt-input::placeholder {
    color: var(--term-dim);
    opacity: 0.7;
  }

  .prompt-input:focus {
    outline: none;
  }

  .prompt-hint {
    margin: 0;
    color: var(--term-dim);
    font-size: 0.9rem;
  }

  .prompt-hint code {
    color: var(--term-green);
    background: transparent;
  }

  .prompt-link {
    color: var(--term-blue);
    text-decoration: none;
    display: inline-flex;
    align-items: center;
    min-height: 44px;
  }

  .prompt-link:hover,
  .prompt-link:focus-visible {
    color: var(--term-green);
    text-decoration: underline;
  }

  .sr-only {
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip: rect(0, 0, 0, 0);
    white-space: nowrap;
    border: 0;
  }
</style>
