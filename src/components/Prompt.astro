<section id="prompt-section" class="prompt-shell" aria-label="Interactive terminal prompt">
  <div class="prompt-output" data-prompt-output role="log" aria-live="polite" aria-relevant="additions"></div>

  <div class="prompt-entry">
    <label for="prompt-command" class="sr-only">Terminal command</label>
    <span class="prompt" aria-hidden="true">pasha@portfolio:~$</span>
    <input
      id="prompt-command"
      name="cmd"
      class="prompt-input"
      type="text"
      inputmode="text"
      autocomplete="off"
      spellcheck="false"
      aria-describedby="prompt-hint"
      placeholder=""
    >
    <span class="cursor" aria-hidden="true"></span>
  </div>

  <p id="prompt-hint" class="prompt-hint">Type <code>help</code> and press Enter. Shortcut: <code>/</code> focuses prompt.</p>

  <noscript>
    <p class="prompt-hint">JavaScript is off. Visit <a href="/blog">/blog</a> or open <a href="/files/resume-cv.pdf">resume.pdf</a>.</p>
  </noscript>
</section>

<script is:inline>
  (() => {
    const section = document.getElementById('prompt-section');
    const input = document.getElementById('prompt-command');
    const output = section?.querySelector('[data-prompt-output]');

    if (!input || !output) {
      return;
    }

    const MAX_HISTORY = 50;
    const MAX_OUTPUT_LINES = 180;
    const commandHistory = [];
    let historyIndex = 0;

    const cursor = section?.querySelector('.cursor');
    const promptEntry = section?.querySelector('.prompt-entry');
    const promptLabel = section?.querySelector('.prompt-entry .prompt');
    const measure = document.createElement('span');\n    const canvas = document.createElement('canvas');\n    const context = canvas.getContext('2d');

    const updateCursorPosition = () => {
      if (!cursor || !promptEntry || !promptLabel || !(input instanceof HTMLInputElement)) {
        return;
      }
      
      // Keep cursor anchor aligned with prompt width.
      const promptWidth = promptLabel.getBoundingClientRect().width;
      promptEntry.style.setProperty('--prompt-width', `${promptWidth}px`);

      const inputStyle = window.getComputedStyle(input);
      measure.style.position = 'absolute';
      measure.style.visibility = 'hidden';
      measure.style.pointerEvents = 'none';
      measure.style.whiteSpace = 'pre';
      measure.style.left = '-9999px';
      measure.style.top = '0';
      measure.style.font = inputStyle.font;
      measure.style.letterSpacing = inputStyle.letterSpacing;
      measure.style.textTransform = inputStyle.textTransform;

      if (!measure.isConnected) {
        promptEntry.appendChild(measure);
      }

      const cursorPos = input.selectionStart || 0;
      const textBeforeCursor = input.value.slice(0, cursorPos).replace(/ /g, '\u00a0');
      measure.textContent = textBeforeCursor;

      const width = measure.getBoundingClientRect().width;
      const inputRect = input.getBoundingClientRect();
      const entryRect = promptEntry.getBoundingClientRect();
      const fontSize = parseFloat(inputStyle.fontSize) || 16;
      const parsedLineHeight = parseFloat(inputStyle.lineHeight);
      const lineHeight = Number.isFinite(parsedLineHeight) ? parsedLineHeight : fontSize * 1.2;
      const cursorHeight = fontSize;
      const lineTopOffset = Math.max(0, (inputRect.height - lineHeight) / 2);
      const glyphTopOffset = Math.max(0, (lineHeight - fontSize) / 2);
      const cursorCompensation = Math.max(0, (fontSize - cursorHeight) / 2);
      const top = inputRect.top - entryRect.top + lineTopOffset + glyphTopOffset + cursorCompensation;

      cursor.style.left = `calc(var(--prompt-width, 0px) + 8px + ${Math.max(0, width - input.scrollLeft)}px)`;
      cursor.style.top = `${top}px`;\n      cursor.style.height = `${cursorHeight}px`;
    };

    const isEditableTarget = (target) => {
      if (!(target instanceof HTMLElement)) return false;
      if (target.isContentEditable) return true;
      const tag = target.tagName;
      return tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT';
    };

    const trimOutput = () => {
      while (output.childElementCount > MAX_OUTPUT_LINES) {
        output.firstElementChild?.remove();
      }
      output.scrollTop = output.scrollHeight;
    };

    const appendCommand = (text) => {
      const line = document.createElement('p');
      line.className = 'prompt-line prompt-line-command';

      const promptLabel = document.createElement('span');
      promptLabel.className = 'prompt';
      promptLabel.textContent = 'pasha@portfolio:~$';
      line.appendChild(promptLabel);
      line.append(` ${text}`);

      output.appendChild(line);
      trimOutput();
    };

    const appendResponse = (text) => {
      const line = document.createElement('p');
      line.className = 'prompt-line prompt-line-response';
      line.textContent = text;
      output.appendChild(line);
      trimOutput();
    };

    const appendLink = (label, href, external = false) => {
      const line = document.createElement('p');
      line.className = 'prompt-line prompt-line-response';

      const anchor = document.createElement('a');
      anchor.className = 'prompt-link';
      anchor.href = href;
      anchor.textContent = label;
      if (external) {
        anchor.target = '_blank';
        anchor.rel = 'noreferrer noopener';
      }

      line.appendChild(anchor);
      output.appendChild(line);
      trimOutput();
    };

    const printHelp = () => {
      appendResponse('about  - show short bio');
      appendResponse('links  - show primary links');
      appendResponse('blog   - open /blog');
      appendResponse('resume - open resume.pdf');
      appendResponse('clear  - clear terminal output');
      appendResponse('help   - show this help');
    };

    const runCommand = (rawValue) => {
      const value = rawValue.trim();
      if (!value) return;

      const command = value.toLowerCase();

      // Preserve terminal behavior: clear should wipe the screen entirely, including the typed line.
      if (command === 'clear') {
        output.innerHTML = '';
        return;
      }

      appendCommand(value);

      switch (command) {
        case 'about':
          appendResponse('Pasha Fateev - software engineer focused on reliable backend systems with Python and Go.');
          appendResponse('Currently building release engineering automation and practical AI-assisted workflows.');
          break;
        case 'links':
          appendLink('github     https://github.com/pashafateev', 'https://github.com/pashafateev', true);
          appendLink('linkedin   https://www.linkedin.com/in/pashafateev/', 'https://www.linkedin.com/in/pashafateev/', true);
          appendLink('blog       /blog', '/blog');
          appendLink('resume     /files/resume-cv.pdf', '/files/resume-cv.pdf', true);
          break;
        case 'blog':
          window.location.assign('/blog');
          break;
        case 'resume': {
          const resumeUrl = '/files/resume-cv.pdf';
          const win = window.open(resumeUrl, '_blank', 'noopener');
          if (!win) {
            window.location.assign(resumeUrl);
          }
          appendResponse('Opening resume.pdf...');
          break;
        }
        case 'help':
          printHelp();
          break;
        default:
          appendResponse(`Command not found: ${command}. Type "help" for available commands.`);
      }
    };

    const submitCommand = () => {
      const value = input.value.trim();
      if (!value) return;

      commandHistory.push(value);
      if (commandHistory.length > MAX_HISTORY) {
        commandHistory.shift();
      }
      historyIndex = commandHistory.length;

      runCommand(value);
      input.value = '';
      updateCursorPosition();
    };

    // Update cursor on input
    input.addEventListener('input', updateCursorPosition);
    input.addEventListener('click', updateCursorPosition);
    input.addEventListener('keyup', updateCursorPosition);
    
    // Show/hide cursor based on focus
    input.addEventListener('focus', () => {
      if (cursor) cursor.style.opacity = '1';
      updateCursorPosition();
    });
    
    input.addEventListener('blur', () => {
      if (cursor) cursor.style.opacity = '0';
    });
    
    // Initialize cursor position
    updateCursorPosition();

    input.addEventListener('keydown', (event) => {
      if (event.key === 'Enter') {
        event.preventDefault();
        submitCommand();
        return;
      }

      if (event.key === 'ArrowUp') {
        if (commandHistory.length === 0) return;
        event.preventDefault();
        historyIndex = Math.max(0, historyIndex - 1);
        input.value = commandHistory[historyIndex] ?? '';
        setTimeout(updateCursorPosition, 0);
        return;
      }

      if (event.key === 'ArrowDown') {
        if (commandHistory.length === 0) return;
        event.preventDefault();
        historyIndex = Math.min(commandHistory.length, historyIndex + 1);
        input.value = historyIndex === commandHistory.length ? '' : commandHistory[historyIndex] ?? '';
        setTimeout(updateCursorPosition, 0);
      }
    });

    document.addEventListener('keydown', (event) => {
      if (event.defaultPrevented || event.altKey || event.ctrlKey || event.metaKey) {
        return;
      }

      const target = event.target;

      if (event.key === '/' && !isEditableTarget(target)) {
        event.preventDefault();
        input.focus();
        return;
      }

      if (event.key === 'Escape' && document.activeElement === input) {
        input.blur();
      }
    });
  })();
</script>

<style>
  .prompt-shell {
    display: grid;
    gap: 10px;
    margin-top: 4px;
  }

  .prompt-output {
    display: grid;
    gap: 6px;
    max-height: min(48vh, 320px);
    overflow-y: auto;
    padding-right: 4px;
  }

  .prompt-line {
    margin: 0;
    word-break: break-word;
  }

  .prompt-line-command {
    color: var(--term-fg);
  }

  .prompt-line-response {
    color: var(--term-dim);
  }

  .prompt-entry {
    position: relative;
    display: grid;
    grid-template-columns: auto minmax(0, 1fr);
    gap: 8px;
    align-items: center;
    min-height: 44px;
  }
  
  .prompt-entry .cursor {
    position: absolute !important;
    left: calc(var(--prompt-width, 0px) + 8px);
    top: 0;
    transform: none;
    pointer-events: none;
    transition: left 50ms ease-out;
    opacity: 0;
    margin: 0 !important;
    display: block !important;
  }
  
  .prompt-input:focus ~ .cursor {
    opacity: 1;
  }

  .prompt-input {
    width: 100%;
    border: 0;
    color: var(--term-fg);
    background: transparent;
    font: inherit;
    min-height: 44px;
    padding: 0;
    caret-color: transparent;
  }

  .prompt-input::placeholder {
    color: var(--term-dim);
    opacity: 0.7;
  }

  .prompt-input:focus {
    outline: none;
  }

  .prompt-hint {
    margin: 0;
    color: var(--term-dim);
    font-size: 0.9rem;
  }

  .prompt-hint code {
    color: var(--term-green);
    background: transparent;
  }

  .prompt-link {
    color: var(--term-blue);
    text-decoration: none;
    display: inline-flex;
    align-items: center;
    min-height: 44px;
  }

  .prompt-link:hover,
  .prompt-link:focus-visible {
    color: var(--term-green);
    text-decoration: underline;
  }

  .sr-only {
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip: rect(0, 0, 0, 0);
    white-space: nowrap;
    border: 0;
  }
</style>
